//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

// <auto-generated/>

using Microsoft.Win32.SafeHandles;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Security.Permissions;

namespace Microsoft.BizQA.NLU.QueryRewrite.Speller
{
    /// <summary>
    /// A safe handle to a Dynamic Link Library (DLL). These are aqcuires and released via
    /// LoadLibrary/FreeLibrary calls.
    /// </summary>
    /// <id guid="a81d2998-2cb6-40c6-b75d-ed013fea41f6" />
    internal sealed class SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        /// <summary>
        /// Create a handle that is invalid initially
        /// </summary>
        /// <id guid="83db5914-c82b-4e29-88d8-1bcfdcf211ed" />
        internal SafeLibraryHandle()
            : base(true)
        {
        }

        /// <summary>
        /// Create a handle to a specified DLL.
        /// </summary>
        /// <param name="dllPath">Path to DLL to load</param>
        /// <exception cref="Win32Exception">If LoadLibrary call fails</exception>
        /// <id guid="83db5914-c82b-4e29-88d8-1bcfdcf211ed" />
        internal SafeLibraryHandle(string dllPath)
            : base(true)
        {
            SetHandle(SecureLibrary.Load(dllPath));
            if (IsInvalid)
            {
                int errorCode = Marshal.GetLastWin32Error();
                throw new Win32Exception(errorCode);
            }
        }

        /// <id guid="44cb1329-fdbc-428c-b240-ef94e6cc0af4" />
        protected override bool ReleaseHandle()
        {
            bool success = NativeMethods.FreeLibrary(handle);
            return success;
        }
    }

    /// <summary>
    /// Wrapper for internal calling of native Windows API's.
    internal static class NativeMethods
    {
        /// <id guid="4b473ccb-12b0-40f1-a08e-e896623dec09" />
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern bool FreeLibrary(IntPtr moduleHandle);

        /// <id guid="50dc518e-4772-4098-ba4b-8d4e569d500d" />
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern IntPtr GetProcAddress(SafeHandle moduleHandle, [MarshalAs(UnmanagedType.LPStr)]string procName);
    }

    /// <summary>
    /// Wrapper to all CSAPI spelling DLL calls.  See //depot/*/nlg/inc/api/spellapi.h
    /// for API details.
    /// </summary>
    /// </summary>
    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    public class SpellingWrapper : IDisposable
    {
        private SafeLibraryHandle _dllHandle;

        /// <id guid="8f7c5fa3-bd0d-4ba2-a3fa-8b4f4b98b564" />
        #region Speller delegates
        private delegate uint SpellerVersionDelegate(ref ProofInfo info);
        /// <id guid="7717a244-546f-4084-9b32-b0bd4bced347" />
        private delegate uint SpellerInitDelegate(out IntPtr id, ref ProofParams pxpar);
        /// <id guid="f4c36579-266b-4018-8e6b-3c345342976f" />
        private delegate uint SpellerTerminateDelegate(IntPtr id, int unused);
        /// <id guid="5d6471ab-5a7c-487c-9e5b-178f2db79306" />
        private delegate uint SpellerOpenLexDelegate(IntPtr id, ref ProofLexIn plxin, ref ProofLexOut plxout);
        /// <id guid="f9048b00-141d-4e30-80e9-5844f7bfdda3" />
        private delegate uint SpellerCloseLexDelegate(IntPtr id, IntPtr lex, int unused);
        /// <id guid="d560b82f-913a-4847-8f75-c5c2a3b8bb26" />
        private delegate uint SpellerSetOptionsDelegate(IntPtr id, OptionSelect select, OptionBit optionValue);

        private delegate uint SpellerGetOptionsDelegate(IntPtr id, OptionSelect select, ref OptionBit options);

        /// <id guid="3913f756-ed93-4263-a89b-b4f3e3518fb0" />
        private delegate uint SpellerCheckDelegate(IntPtr id, CheckCommand scmd, ref SpellerInputBuffer.NativeStruct psib, ref SpellerReturnBuffer.NativeStruct psrb);
        private readonly SpellerVersionDelegate _spellerVersionCall;
        private readonly SpellerOpenLexDelegate _spellerOpenLexCall;
        private readonly SpellerCloseLexDelegate _spellerCloseLexCall;
        private readonly SpellerInitDelegate _spellerInitCall;
        private readonly SpellerTerminateDelegate _spellerTerminateCall;
        private readonly SpellerSetOptionsDelegate _spellerSetOptionsCall;
        private readonly SpellerGetOptionsDelegate _spellerGetOptionsCall;
        private readonly SpellerCheckDelegate _spellerCheckCall;
        #endregion

        /// <exception cref="MissingMethodException">A required method is not exported from the DLL</exception>
        /// <id guid="0cd2e10e-8676-4744-b3b0-fc4b333e9c9b" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public SpellingWrapper(string dllName, string lexName, ushort lcid)
        {
            DllPath = dllName;
            LexiconPath = lexName;
            LanguageId = lcid;

            _dllHandle = new SafeLibraryHandle(DllPath);

            // Obtain strong references to all delegates necessary for spell checking
            _spellerVersionCall = (SpellerVersionDelegate)GetDelegate("SpellerVersion", typeof(SpellerVersionDelegate));
            _spellerInitCall = (SpellerInitDelegate)GetDelegate("SpellerInit", typeof(SpellerInitDelegate));
            _spellerTerminateCall = (SpellerTerminateDelegate)GetDelegate("SpellerTerminate", typeof(SpellerTerminateDelegate));
            _spellerOpenLexCall = (SpellerOpenLexDelegate)GetDelegate("SpellerOpenLex", typeof(SpellerOpenLexDelegate));
            _spellerCloseLexCall = (SpellerCloseLexDelegate)GetDelegate("SpellerCloseLex", typeof(SpellerCloseLexDelegate));
            _spellerSetOptionsCall = (SpellerSetOptionsDelegate)GetDelegate("SpellerSetOptions", typeof(SpellerSetOptionsDelegate));
            _spellerGetOptionsCall = (SpellerGetOptionsDelegate)GetDelegate("SpellerGetOptions", typeof(SpellerGetOptionsDelegate));
            _spellerCheckCall = (SpellerCheckDelegate)GetDelegate("SpellerCheck", typeof(SpellerCheckDelegate));
        }

        /// <summary>
        /// Path to DLL used by this wrapper
        /// </summary>
        /// <id guid="f00f5888-181b-4a85-b5b9-2f874d0f41bb" />
        internal string DllPath { get; private set; }
        /// <summary>
        /// Path to lexicon used by this speller
        /// </summary>
        /// <id guid="c804ec2a-34c8-4eb2-8149-c07af9153080" />
        public string LexiconPath { get; private set; }
        /// <summary>
        /// Language that this speller can proof
        /// </summary>
        /// <id guid="dae9f6cc-0aea-4974-b73f-87d9fb1c7bcb" />
        internal ushort LanguageId { get; private set; }

        /// <summary>
        /// Obtain a delegate to the specified function in the spelling DLL
        /// </summary>
        /// <param name="methodName">Method name to search for in the DLL</param>
        /// <param name="delegateType">Delegate signate expected of method</param>
        /// <returns>Delegate that can be called to invoke the unmanged code</returns>
        /// <exception cref="MissingMethodException">Specified method name doesn't exist in the spelling
        /// DLL</exception>
        /// <id guid="a8afcba2-4ca2-4fd3-8e22-4b9eef455b66" />
        private Delegate GetDelegate(string methodName, Type delegateType)
        {
            IntPtr procAddress = NativeMethods.GetProcAddress(_dllHandle, methodName);
            if (IntPtr.Zero == procAddress)
            {
                int errorCode = Marshal.GetLastWin32Error();
                throw new MissingMethodException(
                    string.Format
                        (CultureInfo.InvariantCulture,
                        "Failed to load DLL method {0} from dll {1}",
                        methodName, DllPath),
                    new Win32Exception(errorCode));
            }
            return Marshal.GetDelegateForFunctionPointer(procAddress, delegateType);
        }

        /// <summary>
        /// Process a return code from the unmanaged API's. If success, does nothing.  If function not supported, log and move on.
        /// If error code, a ProofingExcpetion is thrown.
        /// </summary>
        /// <param name="error"></param>
        /// <param name="functionTried">string representation of the not-supported function for logging purposes</param>-->
        /// <id guid="99bfaf2e-8055-4672-b8e9-3de7071184e6" />
        private static void ProcessProofingReturn(uint error, string functionTried)
        {
            if (error == (uint)ProofingException.MajorErrorCode.NotSupported)
            {
                ;
            }
            else if (error != (uint)ProofingException.MajorErrorCode.NoErrors)
            {
                throw ProofingException.Create(error);
            }
        }

        /// <summary>
        /// Obtain version information from the spelling DLL.
        /// </summary>
        /// <returns>Proofing information containg information about version of the API</returns>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="b9a414f5-35a7-4902-8475-16848248a82d" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public ProofInfo GetVersion()
        {
            ProofInfo info = new ProofInfo();
            ProcessProofingReturn(_spellerVersionCall(ref info), "getVersion");
            return info;
        }

        /// <summary>
        /// Initialize the spelling engine for this thread. The returned pointer should be used for
        /// ALL future API calls from this thread, and must be properly closed with
        /// <see cref="Terminate">Terminate</see> when complete. Each thread should
        /// call Init exactly once, sharing the same Init value across thread will result in undefined
        /// behavior.
        /// </summary>
        /// <param name="proofingParameters">Parameters specifiying which version of the API expected</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <returns>Identifier that all subsequent API calls by this thread should use</returns>
        /// <id guid="14c19d8c-f51d-467b-92f8-8ada751665cc" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public IntPtr Init(ref ProofParams proofingParameters)
        {
            ProcessProofingReturn(_spellerInitCall(out IntPtr id, ref proofingParameters), "initialize");
            return id;
        }

        /// <summary>
        /// Terminate an instance of the spelling engine that was previously opened with
        /// <see cref="Init">Init</see>. This should be called once a thread has finished with the
        /// engine. The id will no longer be valid.
        /// </summary>
        /// <param name="id">ID returned from Init</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="2a685825-b572-43b9-8f8b-175ea76f072d" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void Terminate(IntPtr id)
        {
            ProcessProofingReturn(_spellerTerminateCall(id, 0), "terminate");
        }

        /// <summary>
        /// Open a lexicon for spell checking from disk. Call <see cref="CloseLexicon">CloseLexicon</see>
        /// to unload the lexicon.
        /// </summary>
        /// <param name="id">ID returned from Init</param>
        /// <param name="desiredLexicon">Lexicon information about the lexicon that should be loaded</param>
        /// <param name="loadedLexicon">Lexicon information about the lexicon that was located</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="38d273c7-1d2c-4e8e-8568-f5b93399c490" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void OpenLexicon(IntPtr id, ref ProofLexIn desiredLexicon, ref ProofLexOut loadedLexicon)
        {
            ProcessProofingReturn(_spellerOpenLexCall(id, ref desiredLexicon, ref loadedLexicon), "openLexicon");
        }

        /// <summary>
        /// Close a lexicon previously opened with <see cref="CloseLexicon">CloseLexicon</see>.
        /// </summary>
        /// <param name="id">ID returned from Init</param>
        /// <param name="lex">Lexicon ID (Obtained from
        /// <see cref="ProofLexOut.LexiconID">ProofLexOut.LexiconID</see>)</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="0f23bf36-ca78-4c74-ae57-2adccfea05b0" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void CloseLexicon(IntPtr id, IntPtr lex)
        {
            ProcessProofingReturn(_spellerCloseLexCall(id, lex, 0), "closeLexicon");
        }

        #region Speller Options

        public enum OptionBit : uint
        {
            /// <summary>
            /// Suggest from user dictionaries.
            /// </summary>
            SuggestFromUserLex = 0x00000001,

            /// <summary>
            /// Ignore words in all UPPERCASE.
            /// </summary>
            IgnoreAllCaps = 0x00000002,

            /// <summary>
            /// Ignore words with any numbers in it.
            /// </summary>
            IgnoreMixedDigits = 0x00000004,

            /// <summary>
            /// Ignore words composed of all roman numerals.
            /// </summary>
            IgnoreRomanNumerals = 0x00000008,

            /// <summary>
            /// Flag repeated words
            /// </summary>
            FindRepeatWord = 0x00000040,

            /// <summary>
            /// Rate the suggestions on scale of 1-255, 255 being most likely
            /// </summary>
            RateSuggestions = 0x00000400,

            /// <summary>
            /// Flag words starting with number(s)
            /// </summary>
            FindInitialNumerals = 0x00000800,

            /// <summary>
            /// Break after each suggestion task for faster return of control to the application.
            /// </summary>
            SglStepSugg = 0x00010000,

            /// <summary>
            /// Do not check single letters: e.g., "a)".
            /// </summary>
            IgnoreSingleLetter = 0x00020000,

            /// <summary>
            /// Ignore words with initial letter capped 
            /// </summary>
            IgnoreInitialCap = 0x00040000,

            /// <summary>
            /// Language mode mask
            /// </summary>
            LangMode = 0xF0000000,
            /* Hebrew Language Modes -- (CT only) */
            HebrewFullScript = 0x00000000,
            HebrewPartialScript = 0x10000000,
            HebrewMixedScript = 0x20000000,
            HebrewMixedAuthorizedScript = 0x30000000,
            /* French Language Modes -- (HM only) */
            FrenchDialectDefault = 0x00000000,
            FrenchUnaccentedUppercase = 0x10000000,
            FrenchAccentedUppercase = 0x20000000,
            FrenchPreReform = 0x40000000,
            FrenchPostReform = 0x80000000,
            /* Russian Language Modes -- (HM only) */
            RussianDialectDefault = 0x00000000,
            RussianIE = 0x10000000,
            RussianIO = 0x20000000,
            /* Korean Language Modes */
            /// <summary>
            /// Auxiliary verb and Auxiliary adjective can combine together.
            /// </summary>
            KoreanNoAuxCombine = 0x10000000,
            /// <summary>
            /// Search frequently-misspelled-word dictionary.
            /// </summary>
            KoreanNoMissSpellDictSearch = 0x20000000,
            /// <summary>
            /// Do not search frequently-misspelled word dictionary 
            /// </summary>
            KoreanNoCompoundNounProc = 0x40000000,
            KoreanDefault = 0,
            /* German Language Modes */

            /// <summary>
            /// Use prereform spelling 
            /// </summary>
            GermanUsePrereform = 0x10000000,

            /* Arabic Language Modes - 2/25/00 */
            ArabicNone = 0x00000000,
            ArabicStrictAlefHamza = 0x10000000,
            ArabicStrictFinalYaa = 0x20000000,
            ArabicBothStrict = 0x30000000,

            /*Portuguese Language Modes */
            PortuguesePostReform = 0x20000000,
            PortuguesePreReform = 0x10000000
        }

        public enum OptionSelect
        {
            /// <summary>
            /// Set bit-oriented options (as before).
            /// </summary>
            Bits,
            /// <summary>
            /// GetOptions only.  The returned value shows which options can be turned on.
            /// </summary>
            PossibleBits,
            /// <summary>
            /// AutoReplaceThreshold (0-255)
            /// </summary>
            AutoReplace,
        }

        #endregion

        /// <summary>
        /// Set options for this instance of the spelling engine. Options are specific to the given
        /// ID from Init
        /// </summary>
        /// <param name="id">ID returned from Init</param>
        /// <param name="select">Type of action to perform on options, use
        /// <see cref="OptionSelect.Bits">OptionSelect.Bits</see> to set bits</param>
        /// <param name="option">Options to set</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="2cac27d3-f72c-4627-970a-3c472d3daa81" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void SetOptions(IntPtr id, OptionSelect select, OptionBit option)
        {
            ProcessProofingReturn(_spellerSetOptionsCall(id, select, option), "setOptions");
        }

        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public OptionBit GetOptions(IntPtr id, OptionSelect select, OptionBit option)
        {
            ProcessProofingReturn(_spellerGetOptionsCall(id, select, ref option), "getOptions");
            return option;
        }

        /// <summary>
        /// Command to the Check method to determine behavior
        /// </summary>
        public enum CheckCommand
        {
            VerifyBuffer = 2,
            Suggest,
            SuggestMore,

            Wildcard = 6, // no reason to support this
            Anagram,    // or this

            VerifyBufferAutoReplace = 10 // Same as VerifyBuffer - but offer AutoReplacements
        }

        /// <summary>
        /// Spell check a span of text. One error will be located, and information about that error
        /// will be returned in result. Suggestions will be available if result.Status is
        /// <see cref="SpellerReturnBuffer.SpellerStatus.ReturningChangeAlways">SpellerStatus.ReturningChangeAlways</see> or
        /// <see cref="SpellerReturnBuffer.SpellerStatus.ReturningAutoReplace">SpellerStatus.ReturningChangeAlways</see>
        /// when command is <see cref="CheckCommand.VerifyBuffer">CheckCommand.VerifyBuffer</see>. For
        /// <see cref="SpellerReturnBuffer.SpellerStatus.UnknownInputWord">SpellerStatus.UnknownInputWord</see>,
        /// <see cref="SpellerReturnBuffer.SpellerStatus.ErrorAccent">SpellerStatus.ErrorAccent</see>,
        /// <see cref="SpellerReturnBuffer.SpellerStatus.ErrorCapitalization">SpellerStatus.ErrorCapitalization</see>, or
        /// <see cref="SpellerReturnBuffer.SpellerStatus.ReturningChangeOnce">SpellerStatus.ReturningChangeOnce</see>, a
        /// second call with command set to <see cref="CheckCommand.Suggest">CheckCommand.Suggest</see> to obtain
        /// selections.
        /// </summary>
        /// <param name="id">ID returned from Init</param>
        /// <param name="command">CheckCommand to execute</param>
        /// <param name="input">Input buffer containing string and cosntraints for checking</param>
        /// <param name="result">Resulting error/success information</param>
        /// <exception cref="ProofingException">Unmanged code returned a non-success result</exception>
        /// <id guid="56b31536-24c5-4ca6-b4da-aa04065b9d34" />
        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
        public void Check(IntPtr id, CheckCommand command,
            ref SpellerInputBuffer input, ref SpellerReturnBuffer result)
        {
            ProcessProofingReturn(_spellerCheckCall(id, command, ref input._Native, ref result._Native), "check");
        }

        #region IDisposable Members

        /// <id guid="fb7a7b17-d620-4a01-80b4-9688fd5e7164" />
        protected void Dispose(bool disposing)
        {
            if (_dllHandle != null)
            {
                _dllHandle.Dispose();
                _dllHandle = null;
            }
            if (disposing)
            {
                GC.SuppressFinalize(this);
            }
        }

        /// <id guid="fb7a7b17-d620-4a01-80b4-9688fd5e7164" />
        public void Dispose()
        {
            Dispose(true);
        }

        #endregion

        /// <id guid="b0a2a06d-a606-4291-9c9c-ee959b4fa787" />
        ~SpellingWrapper()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Basic information about the API
    /// </summary>
    /// <id guid="398c4f05-dd79-4755-9d0b-ba023a07c261" />
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct ProofInfo
    {
        public string Copyright;
        public uint VersionAPI;
        public uint VersionVendor;
        public int VendorId;
        public uint cchCopyright;
        public uint XCap;
    }

    public enum ProofLexType
    {
        ChangeOnce = 0,
        ChangeAlways,
        User,
        Exclue,
        Main,
        SysUdr,
        Max,
        CustomFlags,
        CSSMain,
        IgnoreAlways = User
    }

    /// <summary>
    /// Information used to request opening of lexicons.
    /// </summary>
    /// <id guid="620b128a-49be-45c7-9787-93c277ec3e05" />
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct ProofLexIn
    {
        public string LexiconPath;
        // really a BOOL, but so be it
        public int Create;
        public ProofLexType LexiconType;
        public ushort ExpectedLanguageID;
    }

    /// <summary>
    /// Information returned form a successful lexicon open.
    /// </summary>
    /// <id guid="93800ec1-8d14-4072-807f-d80168e5e534" />
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct ProofLexOut
    {
        public readonly string Copyright;
        public readonly IntPtr LexiconID;
        public readonly uint CopyrightLength;
        public readonly uint Version;
        // really a BOOL, but so be it
        public readonly int ReadOnly;
        public readonly ushort LanguageID;
    }

    /// <summary>
    /// Initialization structure to API
    /// </summary>
    /// <id guid="4829d6ea-3bf6-45f5-a17b-2a008924aef9" />
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct ProofParams
    {
        public uint VersionAPI;
    }

    /// <summary>
    /// Input buffer used to send information into the Spell check command
    /// </summary>
    /// <id guid="b0122fe7-ffdd-43c4-9f24-bc981907460f" />
    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    public class SpellerInputBuffer : IDisposable
    {
        /// <id guid="42863584-afdc-4450-8c1a-53dd73caba56" />
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct NativeStruct
        {
            internal string _inputBuffer;
            internal IntPtr /*PROOFLEX**/ _LexiconArray;
            internal IntPtr /*size_t*/ _inputBufferSize;
            internal IntPtr /*size_t*/ _LexiconCount;
            [MarshalAs(UnmanagedType.U4)]
            internal SpellerStates _state;
            internal uint _processingStartIndex;
            internal IntPtr /*size_t*/ _processingLength;
        }

        internal NativeStruct _Native;

        public SpellerStates State { set { _Native._state = value; } }

        /// <id guid="33c19e71-2e8a-40e2-88f1-c6a74e739482" />
        public SpellerInputBuffer(ProofLexOut[] Lexicons)
        {
            _Native = new NativeStruct
            {
                _LexiconArray = Marshal.AllocCoTaskMem(Lexicons.Length * IntPtr.Size)
            };
            IntPtr current = _Native._LexiconArray;
            for (int i = 0; i < Lexicons.Length; ++i)
            {
                Marshal.StructureToPtr(Lexicons[i].LexiconID, current, false);
                current = new IntPtr(current.ToInt64() + IntPtr.Size);
            }
            _Native._LexiconCount = /* size_t */ (IntPtr)Lexicons.Length;
            _Native._state = SpellerStates.NoStateInfo;
        }

        /// <summary>
        /// Get/Set input string. Setting string reverts start/length processing values
        /// </summary>
        /// <id guid="e139517e-a59e-4006-857d-39955800730d" />
        public string Input
        {
            get { return _Native._inputBuffer; }
            set
            {
                _Native._inputBuffer = value;
                _Native._inputBufferSize = /* size_t */ (IntPtr)value.Length;
                _Native._processingStartIndex = 0;
                _Native._processingLength = _Native._inputBufferSize;
            }
        }

        /// <summary>
        /// Get the length of the processed region, starting from the beginning of the string
        /// </summary>
        /// <id guid="471bfcae-e03a-4b0f-8053-2292be7c7bbb" />
        public uint ProcessingLength { get { return (uint)_Native._processingLength; } }

        /// <summary>
        /// Set the processing range from start to start + length
        /// </summary>
        /// <param name="start">Index into input to start checking</param>
        /// <param name="length">Number of characters to check</param>
        /// <exception cref="ArgumentException">If start + length is larger than the length of input
        /// </exception>
        /// <id guid="2aa20d1a-e251-42b5-a392-7f2f1e077c5c" />
        public void SetProcessingRange(uint start, uint length)
        {
            if (start + length > _Native._inputBufferSize.ToInt64())
            {
                throw new ArgumentOutOfRangeException("length", start + length,
                    "Sum of start + length is greater than input length.");
            }

            _Native._processingStartIndex = start;
            _Native._processingLength = /* size_t */ (IntPtr)length;
        }

        /// <summary>
        /// Set the processing range from start to the end of the string
        /// </summary>
        /// <param name="start">Index into input to start checking</param>
        /// <exception cref="ArgumentException">If start is larger than the length of input</exception>
        /// <id guid="2aa20d1a-e251-42b5-a392-7f2f1e077c5c" />
        public void SetProcessingRange(uint start)
        {
            if (start > _Native._inputBufferSize.ToInt64())
            {
                throw new ArgumentOutOfRangeException("start", start,
                    "Start is greater than input length.");
            }

            _Native._processingStartIndex = start;
            _Native._processingLength = new IntPtr(_Native._inputBufferSize.ToInt64() - start);
        }

        #region IDisposable Members

        /// <id guid="a9dbec39-d1db-4062-886f-2ad9932f9815" />
        protected void Dispose(bool disposing)
        {
            if (_Native._LexiconArray != IntPtr.Zero)
            {
                Marshal.FreeCoTaskMem(_Native._LexiconArray);
                _Native._LexiconArray = IntPtr.Zero;
            }

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }
        }

        /// <id guid="a9dbec39-d1db-4062-886f-2ad9932f9815" />
        public void Dispose()
        {
            Dispose(true);
        }

        /// <id guid="bc3bdab7-1339-4ec3-995d-71511fa4eadf" />
        ~SpellerInputBuffer()
        {
            Dispose(false);
        }

        #endregion
    }

    /// <summary>
    /// Suggestion returned from spell check
    /// 
    /// NOTE: If you change the CharSet property you need to also change the SpellerReturnBuffer
    /// constructor. The allocation of memory for _suggestionStrings depends on this value.
    /// </summary>
    /// <id guid="349f7d11-38d7-4a96-8d67-14ff20748a8e" />
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal class SpellerSuggestion
    {
        internal string _Suggestion;
        internal uint _InputWordOffset;
        internal uint _InputWordLength;
        internal uint _Rating;
    }

    /// <summary>
    /// Return structure from spell check, containing all information about errors located int he string
    /// </summary>
    /// <id guid="2b7a8d7a-ec2f-4a62-be1f-43dfd2dd84d9" />
    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
    public class SpellerReturnBuffer : IDisposable
    {
        public enum SpellerStatus
        {
            NoErrors,          /* All buffer processed. */
            UnknownInputWord,  /* Unknown word. */
            ReturningChangeAlways, /* Returning a Change Always word in SRB. */
            ReturningChangeOnce,  /* Returning a Change Once word in SRB. */
            InvalidHyphenation,   /* obsolete - Error in hyphenation point.*/
            ErrorCapitalization,   /* Cap pattern not valid. */
            WordConsideredAbbreviation, /* Word is considered an abbreviation. */
            HyphChangesSpelling, /* obsolete - Word changes spelling when not hyphenated. */
            NoMoreSuggestions,  /* All methods used. */
            MoreInfoThanBufferCouldHold,  /* More suggestions than could fit in SRB. */
            NoSentenceStartCap,  /* obsolete - Start of sentence was not capitalized. */
            RepeatWord,    /* Repeat word found. */
            ExtraSpaces,   /* obsolete - Too many spaces for context.*/
            MissingSpace, /* obsolete - Too few space(s) between words or sentences. */
            InitialNumeral,  /* Word starts with numeral & sobitFlagInitialNumeral set */
            NoErrorsUDHit, /* obsolete - No errors, but at least 1 word found in user dicts */
            ReturningAutoReplace,  /* Returning an AutoReplace suggestion in WSRB */
            ErrorAccent,   /* accents not valid - returns correctly accented word */
            ContextError   /* contextual errors */
        }

        private const uint MaxSingleSuggestionLength = 64; // Defined by NLG
        public const uint MaxSuggestionCount = 5;

        /// <id guid="83d758f1-581c-4b81-8f3e-8c396a8ebda1" />
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct NativeStruct
        {
            internal IntPtr _suggestionStrings;
            internal IntPtr _suggestionArray;
            internal uint _errorOffset;
            internal uint _errorLength;
            internal uint _processedOffset;
            internal uint _processedLength;
            [MarshalAs(UnmanagedType.I4)]
            internal SpellerStatus _status;
            internal uint _suggestionCount;
            internal uint _allocatedSuggestionBufferCount;
            internal uint _suggestionStringSize;
            internal uint _allocatedSuggestionStringBufferCount;
        }

        internal NativeStruct _Native;

        public SpellerStatus Status { get { return _Native._status; } }
        public uint ErrorOffset { get { return _Native._errorOffset; } }
        public uint ErrorLength { get { return _Native._errorLength; } }
        public uint SuggestionCount { get { return _Native._suggestionCount; } }
        public uint ProcessedLength { get { return _Native._processedLength; } }

        /// <id guid="a397e0aa-a7bf-4cbe-9f59-daba5b0c8553" />
        public SpellerReturnBuffer()
        {
            _Native._allocatedSuggestionStringBufferCount = ((MaxSingleSuggestionLength + 1) *
                MaxSuggestionCount + 1);
            // NOTE: Since we are using Unicode in the CharSet property of the StructLayout attribute 
            // of the SpellerSuggestion class, chars will be 2 byte long. We are hardcoding this value 
            // because there is no way in C# to tie the CharSet value to the sizeof char
            _Native._suggestionStrings = Marshal.AllocCoTaskMem((int)(_Native._allocatedSuggestionStringBufferCount * 2));
            _Native._allocatedSuggestionBufferCount = MaxSuggestionCount;
            _Native._suggestionArray = Marshal.AllocCoTaskMem((int)(_Native._allocatedSuggestionBufferCount *
                Marshal.SizeOf(typeof(SpellerSuggestion))));
            _Native._status = SpellerStatus.NoErrors;
        }

        private SuggestionEnumeration _enumeratorCache;
        /// <summary>
        /// Get an enumerator used to loop over all suggestions
        /// </summary>
        /// <id guid="0c96db3c-e3f2-428a-ad64-3f50ecf4fe9e" />
        public IEnumerable<string> Suggestions
        {
            get
            {
                return _enumeratorCache ?? (_enumeratorCache = new SuggestionEnumeration(this));
            }
        }

        #region IDisposable Members

        /// <id guid="896c5489-6dd4-495f-9adc-b128a561f4a7" />
        public void Dispose()
        {
            Dispose(true);
        }

        /// <id guid="896c5489-6dd4-495f-9adc-b128a561f4a7" />
        protected void Dispose(bool disposing)
        {
            if (_Native._suggestionStrings != IntPtr.Zero)
            {
                Marshal.FreeCoTaskMem(_Native._suggestionStrings);
                _Native._suggestionStrings = IntPtr.Zero;
            }
            if (_Native._suggestionArray != IntPtr.Zero)
            {
                Marshal.FreeCoTaskMem(_Native._suggestionArray);
                _Native._suggestionArray = IntPtr.Zero;
            }

            if (disposing)
            {
                GC.SuppressFinalize(this);
            }
        }

        /// <id guid="8eb23441-c042-4231-a40c-b960b458cc21" />
        ~SpellerReturnBuffer()
        {
            Dispose(false);
        }
        #endregion

        #region Enumerator definitions

        /// <id guid="30799c78-c5ae-4bfe-a6da-f85b348dcf58" />
        internal class SuggestionEnumeration : IEnumerable<string>
        {
            private readonly SpellerReturnBuffer _returnBuffer;

            /// <id guid="838fb11d-a5ff-4186-b6d4-b8439a2cf87a" />
            internal SuggestionEnumeration(SpellerReturnBuffer buffer)
            {
                _returnBuffer = buffer;
            }

            #region IEnumerable<string> Members

            /// <id guid="85168600-ef87-4197-b213-b4b22124933f" />
            public IEnumerator<string> GetEnumerator()
            {
                return new SuggestionEnumerator(_returnBuffer);
            }

            #endregion

            #region IEnumerable Members

            /// <id guid="85168600-ef87-4197-b213-b4b22124933f" />
            IEnumerator IEnumerable.GetEnumerator()
            {
                return new SuggestionEnumerator(_returnBuffer);
            }

            #endregion
        }

        /// <id guid="e4abc7a0-3520-4fcb-9742-206cfa1669ba" />
        internal class SuggestionEnumerator : IEnumerator<string>
        {
            private static readonly int s_suggestionSize = Marshal.SizeOf(typeof(SpellerSuggestion));
            private readonly SpellerReturnBuffer _returnBuffer;
            private int _currentElement = -1;

            /// <id guid="fbe2905e-3173-497b-b247-f6be423c04ae" />
            public SuggestionEnumerator(SpellerReturnBuffer buffer)
            {
                _returnBuffer = buffer;
            }
            #region IEnumerator<string> Members

            /// <id guid="f627ff4c-3d6e-49e5-b03d-06bf42f27ae4" />
            public string Current
            {
                get
                {
                    if (_currentElement < 0 ||
                        _currentElement >= _returnBuffer._Native._allocatedSuggestionBufferCount ||
                        _currentElement >= _returnBuffer._Native._suggestionCount)
                    {
                        throw new InvalidOperationException();
                    }

                    return ((SpellerSuggestion)Marshal.PtrToStructure(new IntPtr(
                        _returnBuffer._Native._suggestionArray.ToInt64() + (_currentElement * s_suggestionSize)),
                        typeof(SpellerSuggestion)))._Suggestion;
                }
            }

            #endregion

            #region IDisposable Members

            /// <id guid="49f59f33-2efc-449a-a3ba-1e53e368900d" />
            public void Dispose()
            {
            }

            #endregion

            #region IEnumerator Members

            /// <id guid="f627ff4c-3d6e-49e5-b03d-06bf42f27ae4" />
            object IEnumerator.Current
            {
                get { return Current; }
            }

            /// <id guid="d7c5c676-33ff-433b-b5ef-7858135e5fa2" />
            public bool MoveNext()
            {
                if (_currentElement + 1 < _returnBuffer._Native._suggestionCount &&
                    _currentElement + 1 < _returnBuffer._Native._allocatedSuggestionBufferCount)
                {
                    ++_currentElement;
                    return true;
                }
                return false;
            }

            /// <id guid="dee1d28d-c710-4ba7-bc65-487a556d5bf4" />
            public void Reset()
            {
                _currentElement = -1;
            }

            #endregion
        }

        #endregion
    }

    [Flags]
    public enum SpellerStates
    {
        None = 0x0000,

        /// <summary>
        /// Call is continuing from where last call returned.  Must be cleared 
        /// for first call into SpellCheck().
        /// </summary>
        IsContinued = 0x0001,

        /// <summary>
        /// First word in buffer is known to be start of
        /// sentence/paragraph/document.  This is only used if the
        /// fSibIsContinued bit is not set.  It should not be needed if the
        /// fSibIsContinued bit is being used.  If this bit is set during a
        /// suggestion request, suggestions will be capitalized.
        /// </summary>
        StartsSentence = 0x0002,

        /// <summary>
        /// The run of text represented in the SIB is a change from either
        /// a change pair (change always or change once) edit, or from a
        /// user specified change, possibly from a suggestion list presented
        /// to the user.  This text should be checked for repeat word
        /// problems, and possibly sentence status, but should not be subject
        /// to subsequent spell verification or change pair substitutions.
        /// Note that if an app is not using the fSibIsContinued support,
        /// they do not need to pass in these edited changes, thus bypassing
        /// the potential problem, and working faster.
        /// </summary>
        IsEditedChange = 0x0004,

        /// <summary>
        /// App is responsible for checking for all repeat word and sentence
        /// punctuation, and avoiding processing loops such as change always
        /// can=can can.
        /// </summary>
        NoStateInfo = 0x0000,
    }
}
